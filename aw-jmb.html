<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: transparent;
            overflow: hidden;
        }
        #viewer-canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://unpkg.com/meshoptimizer@0.18.1/meshopt_decoder.js"></script>
</head>
<body>
    <canvas id="viewer-canvas"></canvas>
    <script>
        // Configurable Parameters (updated)
        const CONFIG = {
            viewer: {
                top: 0, left: 0, right: 0, bottom: 0, modelScale: 4,
                camera: { position: { x: 0, y: 1, z: 4 }, target: { x: 0, y: 1, z: 0 } }, // y heights same, parametric
                orthoSize: 5, // Parametric ortho "lens" size (width/height of frustum at target)
                cameraHeight: -3.1 // Parametric height for camera and target y
            }
        };

        // Global Variables
        let scene, camera, renderer, controls, clock = new THREE.Clock();
        let mixer = null, currentModel = null;
        let modelAnimations = [];
        let activeHdriIndex = 0; // Use first light

        const hdriPaths = [
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr'
        ];

        // Hardcoded model URL (using the first avatar's model as example)
        const modelUrl = 'https://raw.githubusercontent.com/decentralize-dfw/co/main/warhol-basq-opt-v1.glb';

        initScene();
        loadModelForDisplay(modelUrl);
        animate();

        function initScene() {
    scene = new THREE.Scene();
    scene.background = null;
    const canvasContainer = document.body;
    const width = canvasContainer.clientWidth;
    const height = canvasContainer.clientHeight;
    const aspect = width / height;

    // Create renderer first
    renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('viewer-canvas'),
        antialias: true, alpha: true, powerPreference: 'high-performance'
    });
    renderer.setSize(width, height);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.physicallyCorrectLights = true;

    // Orthographic Camera
    const orthoSize = CONFIG.viewer.orthoSize;
    const orthoHeight = orthoSize;
    const orthoWidth = orthoHeight * aspect;
    camera = new THREE.OrthographicCamera(
        -orthoWidth / 2,
        orthoWidth / 2,
        orthoHeight / 2,
        -orthoHeight / 2,
        0.01,
        1000
    );

    // Set parametric heights
    const camHeight = CONFIG.viewer.cameraHeight;
    camera.position.set(
        CONFIG.viewer.camera.position.x,
        camHeight,
        CONFIG.viewer.camera.position.z
    );

    // Now create controls with renderer.domElement
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(
        CONFIG.viewer.camera.target.x,
        camHeight,
        CONFIG.viewer.camera.target.z
    );

    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = true;
    controls.minDistance = 0.01;
    controls.maxDistance = 8;
    controls.autoRotate = true;
    controls.autoRotateSpeed = .3;
    controls.minPolarAngle = Math.PI / 4;
    controls.maxPolarAngle = Math.PI / 1.5;
    controls.enabled = true;
    controls.update();
    window.addEventListener('resize', onWindowResize);
    setupHDRIEnvironment(activeHdriIndex);
    addBasicLighting();
}

        function setupHDRIEnvironment(hdriIndex = 0) {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            new THREE.RGBELoader().load(hdriPaths[hdriIndex], texture => {
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                scene.environment = envMap;
                texture.dispose();
                pmremGenerator.dispose();
            });
        }

        function addBasicLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 5);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;

            // Update orthographic camera
            const orthoSize = CONFIG.viewer.orthoSize;
            const orthoHeight = orthoSize;
            const orthoWidth = orthoHeight * aspect;
            camera.left = -orthoWidth / 2;
            camera.right = orthoWidth / 2;
            camera.top = orthoHeight / 2;
            camera.bottom = -orthoHeight / 2;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls && controls.enabled) controls.update();
            if (mixer) mixer.update(clock.getDelta());
            if (renderer) renderer.render(scene, camera);
        }

        function loadModelForDisplay(modelUrl) {
            if (!modelUrl) return;
            mixer = null;
            controls.enabled = true;
            const gltfLoader = new THREE.GLTFLoader();
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            gltfLoader.setDRACOLoader(dracoLoader);
            if (typeof MeshoptDecoder !== 'undefined') gltfLoader.setMeshoptDecoder(MeshoptDecoder);
            gltfLoader.load(
                modelUrl,
                gltf => {
                    currentModel = gltf.scene;
                    modelAnimations = gltf.animations || [];
                    centerAndScaleModel(currentModel);
                    setupAnimations(modelAnimations);
                    scene.add(currentModel);
                    resetCameraPosition();
                },
                null,
                error => console.error('Error loading model:', error)
            );
        }

        function centerAndScaleModel(model) {
            if (!model) return;
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            const center = bbox.getCenter(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = CONFIG.viewer.modelScale / maxDim;
            model.scale.set(scale, scale, scale);
            model.position.sub(center.multiplyScalar(scale));
            model.position.y -= 0.8 * scale; // Adjust vertical position if needed
        }

        function resetCameraPosition() {
            camera.near = 0.01;
            camera.far = 1000;
            camera.updateProjectionMatrix();
            const camHeight = CONFIG.viewer.cameraHeight;
            camera.position.set(0, camHeight, 5);
            camera.lookAt(0, camHeight, 0);
            if (controls) {
                controls.target.set(0, camHeight, 0);
                controls.minDistance = 0.001;
                controls.maxDistance = 10;
                controls.update();
            }
        }

        function setupAnimations(animations) {
            if (!animations || animations.length === 0 || !currentModel) return;
            mixer = new THREE.AnimationMixer(currentModel);
            clock = new THREE.Clock();
            clock.start();
            animations.forEach(clip => {
                const action = mixer.clipAction(clip);
                action.setLoop(THREE.LoopRepeat);
                action.play();
            });
            mixer.update(0);
        }
    </script>
</body>
</html>
